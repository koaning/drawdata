import{n as C,t as D}from"./graphlib-Dtxn1kuc.js";import{t as F}from"./clone-o2k1NhhT.js";import{t as L}from"./dagre-B0xEvXH8.js";import{i as O}from"./min-BgkyNW2f.js";import"./purify.es-N-2faAGj.js";import"./marked.esm-BZNXs5FA.js";import"./src-Bp_72rVO.js";import"./chunk-S3R3BYOJ-By1A-M0T.js";import{n as w,r as t}from"./src-faGJHwXX.js";import{b as M}from"./chunk-ABZYJK2D-DAD3GlgM.js";import"./chunk-HN2XXSSU-xW6J7MXn.js";import{t as j}from"./chunk-CVBHYZKI-B6tT645I.js";import"./chunk-ATLVNIR6-DsKp3Ify.js";import"./dist-BA8xhrl2.js";import"./chunk-JA3XYJ7Z-BlmyoDCa.js";import{a as Y,c as k,i as H,l as _,n as z,t as q,u as K}from"./chunk-JZLCHNYA-DBaJpCky.js";import{a as Q,i as U,n as V,r as W,t as Z}from"./chunk-QXUST7PY-CIxWhn5L.js";function X(e){var r={options:{directed:e.isDirected(),multigraph:e.isMultigraph(),compound:e.isCompound()},nodes:$(e),edges:ee(e)};return C(e.graph())||(r.value=F(e.graph())),r}function $(e){return O(e.nodes(),function(r){var n=e.node(r),d=e.parent(r),o={v:r};return C(n)||(o.value=n),C(d)||(o.parent=d),o})}function ee(e){return O(e.edges(),function(r){var n=e.edge(r),d={v:r.v,w:r.w};return C(r.name)||(d.name=r.name),C(n)||(d.value=n),d})}var c=new Map,b=new Map,G=new Map,ne=w(()=>{b.clear(),G.clear(),c.clear()},"clear"),I=w((e,r)=>{let n=b.get(r)||[];return t.trace("In isDescendant",r," ",e," = ",n.includes(e)),n.includes(e)},"isDescendant"),re=w((e,r)=>{let n=b.get(r)||[];return t.info("Descendants of ",r," is ",n),t.info("Edge is ",e),e.v===r||e.w===r?!1:n?n.includes(e.v)||I(e.v,r)||I(e.w,r)||n.includes(e.w):(t.debug("Tilt, ",r,",not in descendants"),!1)},"edgeInCluster"),P=w((e,r,n,d)=>{t.warn("Copying children of ",e,"root",d,"data",r.node(e),d);let o=r.children(e)||[];e!==d&&o.push(e),t.warn("Copying (nodes) clusterId",e,"nodes",o),o.forEach(l=>{if(r.children(l).length>0)P(l,r,n,d);else{let i=r.node(l);t.info("cp ",l," to ",d," with parent ",e),n.setNode(l,i),d!==r.parent(l)&&(t.warn("Setting parent",l,r.parent(l)),n.setParent(l,r.parent(l))),e!==d&&l!==e?(t.debug("Setting parent",l,e),n.setParent(l,e)):(t.info("In copy ",e,"root",d,"data",r.node(e),d),t.debug("Not Setting parent for node=",l,"cluster!==rootId",e!==d,"node!==clusterId",l!==e));let s=r.edges(l);t.debug("Copying Edges",s),s.forEach(f=>{t.info("Edge",f);let E=r.edge(f.v,f.w,f.name);t.info("Edge data",E,d);try{re(f,d)?(t.info("Copying as ",f.v,f.w,E,f.name),n.setEdge(f.v,f.w,E,f.name),t.info("newGraph edges ",n.edges(),n.edge(n.edges()[0]))):t.info("Skipping copy of edge ",f.v,"-->",f.w," rootId: ",d," clusterId:",e)}catch(N){t.error(N)}})}t.debug("Removing node",l),r.removeNode(l)})},"copy"),B=w((e,r)=>{let n=r.children(e),d=[...n];for(let o of n)G.set(o,e),d=[...d,...B(o,r)];return d},"extractDescendants"),ae=w((e,r,n)=>{let d=e.edges().filter(s=>s.v===r||s.w===r),o=e.edges().filter(s=>s.v===n||s.w===n),l=d.map(s=>({v:s.v===r?n:s.v,w:s.w===r?r:s.w})),i=o.map(s=>({v:s.v,w:s.w}));return l.filter(s=>i.some(f=>s.v===f.v&&s.w===f.w))},"findCommonEdges"),S=w((e,r,n)=>{let d=r.children(e);if(t.trace("Searching children of id ",e,d),d.length<1)return e;let o;for(let l of d){let i=S(l,r,n),s=ae(r,n,i);if(i)if(s.length>0)o=i;else return i}return o},"findNonClusterChild"),T=w(e=>!c.has(e)||!c.get(e).externalConnections?e:c.has(e)?c.get(e).id:e,"getAnchorId"),te=w((e,r)=>{if(!e||r>10){t.debug("Opting out, no graph ");return}else t.debug("Opting in, graph ");e.nodes().forEach(function(n){e.children(n).length>0&&(t.warn("Cluster identified",n," Replacement id in edges: ",S(n,e,n)),b.set(n,B(n,e)),c.set(n,{id:S(n,e,n),clusterData:e.node(n)}))}),e.nodes().forEach(function(n){let d=e.children(n),o=e.edges();d.length>0?(t.debug("Cluster identified",n,b),o.forEach(l=>{I(l.v,n)^I(l.w,n)&&(t.warn("Edge: ",l," leaves cluster ",n),t.warn("Descendants of XXX ",n,": ",b.get(n)),c.get(n).externalConnections=!0)})):t.debug("Not a cluster ",n,b)});for(let n of c.keys()){let d=c.get(n).id,o=e.parent(d);o!==n&&c.has(o)&&!c.get(o).externalConnections&&(c.get(n).id=o)}e.edges().forEach(function(n){let d=e.edge(n);t.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(n)),t.warn("Edge "+n.v+" -> "+n.w+": "+JSON.stringify(e.edge(n)));let o=n.v,l=n.w;if(t.warn("Fix XXX",c,"ids:",n.v,n.w,"Translating: ",c.get(n.v)," --- ",c.get(n.w)),c.get(n.v)||c.get(n.w)){if(t.warn("Fixing and trying - removing XXX",n.v,n.w,n.name),o=T(n.v),l=T(n.w),e.removeEdge(n.v,n.w,n.name),o!==n.v){let i=e.parent(o);c.get(i).externalConnections=!0,d.fromCluster=n.v}if(l!==n.w){let i=e.parent(l);c.get(i).externalConnections=!0,d.toCluster=n.w}t.warn("Fix Replacing with XXX",o,l,n.name),e.setEdge(o,l,d,n.name)}}),t.warn("Adjusted Graph",X(e)),A(e,0),t.trace(c)},"adjustClustersAndEdges"),A=w((e,r)=>{var o,l;if(t.warn("extractor - ",r,X(e),e.children("D")),r>10){t.error("Bailing out");return}let n=e.nodes(),d=!1;for(let i of n){let s=e.children(i);d||(d=s.length>0)}if(!d){t.debug("Done, no node has children",e.nodes());return}t.debug("Nodes = ",n,r);for(let i of n)if(t.debug("Extracting node",i,c,c.has(i)&&!c.get(i).externalConnections,!e.parent(i),e.node(i),e.children("D")," Depth ",r),!c.has(i))t.debug("Not a cluster",i,r);else if(!c.get(i).externalConnections&&e.children(i)&&e.children(i).length>0){t.warn("Cluster without external connections, without a parent and with children",i,r);let s=e.graph().rankdir==="TB"?"LR":"TB";(l=(o=c.get(i))==null?void 0:o.clusterData)!=null&&l.dir&&(s=c.get(i).clusterData.dir,t.warn("Fixing dir",c.get(i).clusterData.dir,s));let f=new D({multigraph:!0,compound:!0}).setGraph({rankdir:s,nodesep:50,ranksep:50,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}});t.warn("Old graph before copy",X(e)),P(i,e,f,i),e.setNode(i,{clusterNode:!0,id:i,clusterData:c.get(i).clusterData,label:c.get(i).label,graph:f}),t.warn("New graph after copy node: (",i,")",X(f)),t.debug("Old graph after copy",X(e))}else t.warn("Cluster ** ",i," **not meeting the criteria !externalConnections:",!c.get(i).externalConnections," no parent: ",!e.parent(i)," children ",e.children(i)&&e.children(i).length>0,e.children("D"),r),t.debug(c);n=e.nodes(),t.warn("New list of nodes",n);for(let i of n){let s=e.node(i);t.warn(" Now next level",i,s),s!=null&&s.clusterNode&&A(s.graph,r+1)}},"extractor"),J=w((e,r)=>{if(r.length===0)return[];let n=Object.assign([],r);return r.forEach(d=>{let o=J(e,e.children(d));n=[...n,...o]}),n},"sorter"),ie=w(e=>J(e,e.children()),"sortNodesByHierarchy"),R=w(async(e,r,n,d,o,l)=>{t.warn("Graph in recursive render:XAX",X(r),o);let i=r.graph().rankdir;t.trace("Dir in recursive render - dir:",i);let s=e.insert("g").attr("class","root");r.nodes()?t.info("Recursive render XXX",r.nodes()):t.info("No nodes found for",r),r.edges().length>0&&t.info("Recursive edges",r.edge(r.edges()[0]));let f=s.insert("g").attr("class","clusters"),E=s.insert("g").attr("class","edgePaths"),N=s.insert("g").attr("class","edgeLabels"),p=s.insert("g").attr("class","nodes");await Promise.all(r.nodes().map(async function(g){let a=r.node(g);if(o!==void 0){let u=JSON.parse(JSON.stringify(o.clusterData));t.trace(`Setting data for parent cluster XXX
 Node.id = `,g,`
 data=`,u.height,`
Parent cluster`,o.height),r.setNode(o.id,u),r.parent(g)||(t.trace("Setting parent",g,o.id),r.setParent(g,o.id,u))}if(t.info("(Insert) Node XXX"+g+": "+JSON.stringify(r.node(g))),a==null?void 0:a.clusterNode){t.info("Cluster identified XBX",g,a.width,r.node(g));let{ranksep:u,nodesep:m}=r.graph();a.graph.setGraph({...a.graph.graph(),ranksep:u+25,nodesep:m});let y=await R(p,a.graph,n,d,r.node(g),l),x=y.elem;K(a,x),a.diff=y.diff||0,t.info("New compound node after recursive render XAX",g,"width",a.width,"height",a.height),_(x,a)}else r.children(g).length>0?(t.trace("Cluster - the non recursive path XBX",g,a.id,a,a.width,"Graph:",r),t.trace(S(a.id,r)),c.set(a.id,{id:S(a.id,r),node:a})):(t.trace("Node - the non recursive path XAX",g,p,r.node(g),i),await Y(p,r.node(g),{config:l,dir:i}))})),await w(async()=>{let g=r.edges().map(async function(a){let u=r.edge(a.v,a.w,a.name);t.info("Edge "+a.v+" -> "+a.w+": "+JSON.stringify(a)),t.info("Edge "+a.v+" -> "+a.w+": ",a," ",JSON.stringify(r.edge(a))),t.info("Fix",c,"ids:",a.v,a.w,"Translating: ",c.get(a.v),c.get(a.w)),await W(N,u)});await Promise.all(g)},"processEdges")(),t.info("Graph before layout:",JSON.stringify(X(r))),t.info("############################################# XXX"),t.info("###                Layout                 ### XXX"),t.info("############################################# XXX"),L(r),t.info("Graph after layout:",JSON.stringify(X(r)));let h=0,{subGraphTitleTotalMargin:v}=j(l);return await Promise.all(ie(r).map(async function(g){var u;let a=r.node(g);if(t.info("Position XBX => "+g+": ("+a.x,","+a.y,") width: ",a.width," height: ",a.height),a==null?void 0:a.clusterNode)a.y+=v,t.info("A tainted cluster node XBX1",g,a.id,a.width,a.height,a.x,a.y,r.parent(g)),c.get(a.id).node=a,k(a);else if(r.children(g).length>0){t.info("A pure cluster node XBX1",g,a.id,a.x,a.y,a.width,a.height,r.parent(g)),a.height+=v,r.node(a.parentId);let m=(a==null?void 0:a.padding)/2||0,y=((u=a==null?void 0:a.labelBBox)==null?void 0:u.height)||0,x=y-m||0;t.debug("OffsetY",x,"labelHeight",y,"halfPadding",m),await H(f,a),c.get(a.id).node=a}else{let m=r.node(a.parentId);a.y+=v/2,t.info("A regular node XBX1 - using the padding",a.id,"parent",a.parentId,a.width,a.height,a.x,a.y,"offsetY",a.offsetY,"parent",m,m==null?void 0:m.offsetY,a),k(a)}})),r.edges().forEach(function(g){let a=r.edge(g);t.info("Edge "+g.v+" -> "+g.w+": "+JSON.stringify(a),a),a.points.forEach(u=>u.y+=v/2),Q(a,V(E,a,c,n,r.node(g.v),r.node(g.w),d))}),r.nodes().forEach(function(g){let a=r.node(g);t.info(g,a.type,a.diff),a.isGroup&&(h=a.diff)}),t.warn("Returning from recursive render XAX",s,h),{elem:s,diff:h}},"recursiveRender"),de=w(async(e,r)=>{var l,i,s,f,E,N;let n=new D({multigraph:!0,compound:!0}).setGraph({rankdir:e.direction,nodesep:((l=e.config)==null?void 0:l.nodeSpacing)||((s=(i=e.config)==null?void 0:i.flowchart)==null?void 0:s.nodeSpacing)||e.nodeSpacing,ranksep:((f=e.config)==null?void 0:f.rankSpacing)||((N=(E=e.config)==null?void 0:E.flowchart)==null?void 0:N.rankSpacing)||e.rankSpacing,marginx:8,marginy:8}).setDefaultEdgeLabel(function(){return{}}),d=r.select("g");U(d,e.markers,e.type,e.diagramId),z(),Z(),q(),ne(),e.nodes.forEach(p=>{n.setNode(p.id,{...p}),p.parentId&&n.setParent(p.id,p.parentId)}),t.debug("Edges:",e.edges),e.edges.forEach(p=>{if(p.start===p.end){let h=p.start,v=h+"---"+h+"---1",g=h+"---"+h+"---2",a=n.node(h);n.setNode(v,{domId:v,id:v,parentId:a.parentId,labelStyle:"",label:"",padding:0,shape:"labelRect",style:"",width:10,height:10}),n.setParent(v,a.parentId),n.setNode(g,{domId:g,id:g,parentId:a.parentId,labelStyle:"",padding:0,shape:"labelRect",label:"",style:"",width:10,height:10}),n.setParent(g,a.parentId);let u=structuredClone(p),m=structuredClone(p),y=structuredClone(p);u.label="",u.arrowTypeEnd="none",u.id=h+"-cyclic-special-1",m.arrowTypeStart="none",m.arrowTypeEnd="none",m.id=h+"-cyclic-special-mid",y.label="",a.isGroup&&(u.fromCluster=h,y.toCluster=h),y.id=h+"-cyclic-special-2",y.arrowTypeStart="none",n.setEdge(h,v,u,h+"-cyclic-special-0"),n.setEdge(v,g,m,h+"-cyclic-special-1"),n.setEdge(g,h,y,h+"-cyc<lic-special-2")}else n.setEdge(p.start,p.end,{...p},p.id)}),t.warn("Graph at first:",JSON.stringify(X(n))),te(n),t.warn("Graph after XAX:",JSON.stringify(X(n)));let o=M();await R(d,n,e.type,e.diagramId,void 0,o)},"render");export{de as render};
